{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why would witness verification fail if I build from a feature branch?"}, {"role": "assistant", "content": "Verification fails because the Rego policy enforces building only from the 'main' branch.\n\n**Attack scenario prevented**: Attacker creating malicious code on a feature branch and trying to deploy it.\n\n**Policy enforcement**:\n```rego\ninput.branch != \"main\"  # Detects non-main branches\n```\n\n**How to fix**:\n- Switch to main branch: `git checkout main`\n- Or update policy to allow your branch\n- Or merge feature to main first\n\n**This is a security feature** - policies can restrict builds to specific branches to prevent unauthorized code.\n\n**Policy that detects this**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    input.branch != \"main\"\n    msg := sprintf(\"Must build from main branch, got: %s\", [input.branch])\n}\n```"}], "_metadata": {"scenario": "wrong_branch", "attestor": "git", "error_type": "security_violation"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I prevent Build from unauthorized branch?"}, {"role": "assistant", "content": "Verification fails because the Rego policy enforces building only from the 'main' branch.\n\n**Attack scenario prevented**: Attacker creating malicious code on a feature branch and trying to deploy it.\n\n**Policy enforcement**:\n```rego\ninput.branch != \"main\"  # Detects non-main branches\n```\n\n**How to fix**:\n- Switch to main branch: `git checkout main`\n- Or update policy to allow your branch\n- Or merge feature to main first\n\n**This is a security feature** - policies can restrict builds to specific branches to prevent unauthorized code.\n\n**Detection policy**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    input.branch != \"main\"\n    msg := sprintf(\"Must build from main branch, got: %s\", [input.branch])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "What Rego policy detects Build from unauthorized branch?"}, {"role": "assistant", "content": "Verification fails because the Rego policy enforces building only from the 'main' branch.\n\n**Attack scenario prevented**: Attacker creating malicious code on a feature branch and trying to deploy it.\n\n**Policy enforcement**:\n```rego\ninput.branch != \"main\"  # Detects non-main branches\n```\n\n**How to fix**:\n- Switch to main branch: `git checkout main`\n- Or update policy to allow your branch\n- Or merge feature to main first\n\n**This is a security feature** - policies can restrict builds to specific branches to prevent unauthorized code.\n\n**Detection policy**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    input.branch != \"main\"\n    msg := sprintf(\"Must build from main branch, got: %s\", [input.branch])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why is Build from unauthorized branch a security risk?"}, {"role": "assistant", "content": "Verification fails because the Rego policy enforces building only from the 'main' branch.\n\n**Attack scenario prevented**: Attacker creating malicious code on a feature branch and trying to deploy it.\n\n**Policy enforcement**:\n```rego\ninput.branch != \"main\"  # Detects non-main branches\n```\n\n**How to fix**:\n- Switch to main branch: `git checkout main`\n- Or update policy to allow your branch\n- Or merge feature to main first\n\n**This is a security feature** - policies can restrict builds to specific branches to prevent unauthorized code.\n\n**Detection policy**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    input.branch != \"main\"\n    msg := sprintf(\"Must build from main branch, got: %s\", [input.branch])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why does verification fail when I have uncommitted files?"}, {"role": "assistant", "content": "Verification fails because the working directory has uncommitted changes.\n\n**Attack scenario prevented**: Attacker modifying source code after commit but before build, leaving no git trail.\n\n**Policy enforcement**:\n```rego\ncount(input.status) > 0  # Detects modified/added/deleted files\n```\n\n**How to fix**:\n- Commit your changes: `git add . && git commit -m \"message\"`\n- Or stash them: `git stash`\n- Or update policy to allow dirty working directory (not recommended)\n\n**This is a security feature** - ensures builds are from committed code only.\n\n**Policy that detects this**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    count(input.status) > 0\n    msg := \"Working directory must be clean\"\n}\n```"}], "_metadata": {"scenario": "dirty_working_directory", "attestor": "git", "error_type": "security_violation"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I prevent Uncommitted changes in working directory?"}, {"role": "assistant", "content": "Verification fails because the working directory has uncommitted changes.\n\n**Attack scenario prevented**: Attacker modifying source code after commit but before build, leaving no git trail.\n\n**Policy enforcement**:\n```rego\ncount(input.status) > 0  # Detects modified/added/deleted files\n```\n\n**How to fix**:\n- Commit your changes: `git add . && git commit -m \"message\"`\n- Or stash them: `git stash`\n- Or update policy to allow dirty working directory (not recommended)\n\n**This is a security feature** - ensures builds are from committed code only.\n\n**Detection policy**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    count(input.status) > 0\n    msg := \"Working directory must be clean\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "What Rego policy detects Uncommitted changes in working directory?"}, {"role": "assistant", "content": "Verification fails because the working directory has uncommitted changes.\n\n**Attack scenario prevented**: Attacker modifying source code after commit but before build, leaving no git trail.\n\n**Policy enforcement**:\n```rego\ncount(input.status) > 0  # Detects modified/added/deleted files\n```\n\n**How to fix**:\n- Commit your changes: `git add . && git commit -m \"message\"`\n- Or stash them: `git stash`\n- Or update policy to allow dirty working directory (not recommended)\n\n**This is a security feature** - ensures builds are from committed code only.\n\n**Detection policy**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    count(input.status) > 0\n    msg := \"Working directory must be clean\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why is Uncommitted changes in working directory a security risk?"}, {"role": "assistant", "content": "Verification fails because the working directory has uncommitted changes.\n\n**Attack scenario prevented**: Attacker modifying source code after commit but before build, leaving no git trail.\n\n**Policy enforcement**:\n```rego\ncount(input.status) > 0  # Detects modified/added/deleted files\n```\n\n**How to fix**:\n- Commit your changes: `git add . && git commit -m \"message\"`\n- Or stash them: `git stash`\n- Or update policy to allow dirty working directory (not recommended)\n\n**This is a security feature** - ensures builds are from committed code only.\n\n**Detection policy**:\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    count(input.status) > 0\n    msg := \"Working directory must be clean\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why does verification fail when my build command fails?"}, {"role": "assistant", "content": "Verification fails because the command exited with a non-zero exit code (failure).\n\n**Policy enforcement**:\n```rego\ninput.exitcode != 0  # Detects failed commands\n```\n\n**Common exit codes**:\n- 0: Success\n- 1: General failure\n- 2: Misuse of command\n- 127: Command not found\n\n**How to fix**:\n- Fix the build error\n- Check stderr in attestation: `jq '.predicate.attestations[] | select(.type | contains(\"command-run\")) | .attestation.stderr' attestation.json`\n- Run command locally to debug\n\n**Why this matters**: Failed builds shouldn't pass verification - you want to catch build failures.\n\n**Policy that detects this**:\n```rego\npackage commandrun\n\nimport rego.v1\n\ndeny contains msg if {\n    input.exitcode != 0\n    msg := sprintf(\"Build failed with exit code %d\", [input.exitcode])\n}\n```"}], "_metadata": {"scenario": "build_failed", "attestor": "command-run", "error_type": "security_violation"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I prevent Command exited with non-zero code?"}, {"role": "assistant", "content": "Verification fails because the command exited with a non-zero exit code (failure).\n\n**Policy enforcement**:\n```rego\ninput.exitcode != 0  # Detects failed commands\n```\n\n**Common exit codes**:\n- 0: Success\n- 1: General failure\n- 2: Misuse of command\n- 127: Command not found\n\n**How to fix**:\n- Fix the build error\n- Check stderr in attestation: `jq '.predicate.attestations[] | select(.type | contains(\"command-run\")) | .attestation.stderr' attestation.json`\n- Run command locally to debug\n\n**Why this matters**: Failed builds shouldn't pass verification - you want to catch build failures.\n\n**Detection policy**:\n```rego\npackage commandrun\n\nimport rego.v1\n\ndeny contains msg if {\n    input.exitcode != 0\n    msg := sprintf(\"Build failed with exit code %d\", [input.exitcode])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "What Rego policy detects Command exited with non-zero code?"}, {"role": "assistant", "content": "Verification fails because the command exited with a non-zero exit code (failure).\n\n**Policy enforcement**:\n```rego\ninput.exitcode != 0  # Detects failed commands\n```\n\n**Common exit codes**:\n- 0: Success\n- 1: General failure\n- 2: Misuse of command\n- 127: Command not found\n\n**How to fix**:\n- Fix the build error\n- Check stderr in attestation: `jq '.predicate.attestations[] | select(.type | contains(\"command-run\")) | .attestation.stderr' attestation.json`\n- Run command locally to debug\n\n**Why this matters**: Failed builds shouldn't pass verification - you want to catch build failures.\n\n**Detection policy**:\n```rego\npackage commandrun\n\nimport rego.v1\n\ndeny contains msg if {\n    input.exitcode != 0\n    msg := sprintf(\"Build failed with exit code %d\", [input.exitcode])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why is Command exited with non-zero code a security risk?"}, {"role": "assistant", "content": "Verification fails because the command exited with a non-zero exit code (failure).\n\n**Policy enforcement**:\n```rego\ninput.exitcode != 0  # Detects failed commands\n```\n\n**Common exit codes**:\n- 0: Success\n- 1: General failure\n- 2: Misuse of command\n- 127: Command not found\n\n**How to fix**:\n- Fix the build error\n- Check stderr in attestation: `jq '.predicate.attestations[] | select(.type | contains(\"command-run\")) | .attestation.stderr' attestation.json`\n- Run command locally to debug\n\n**Why this matters**: Failed builds shouldn't pass verification - you want to catch build failures.\n\n**Detection policy**:\n```rego\npackage commandrun\n\nimport rego.v1\n\ndeny contains msg if {\n    input.exitcode != 0\n    msg := sprintf(\"Build failed with exit code %d\", [input.exitcode])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why does verification fail with 'unauthorized functionary'?"}, {"role": "assistant", "content": "Verification fails because the attestation was signed by a key not in the policy's functionaries list.\n\n**Attack scenario prevented**: Attacker with stolen/different key trying to create fraudulent attestations.\n\n**Policy structure**:\n```json\n{\n  \"publickeys\": {\n    \"allowed-key-id\": {\n      \"keyid\": \"sha256:abc123...\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----...\"\n    }\n  },\n  \"steps\": {\n    \"build\": {\n      \"functionaries\": [{\n        \"type\": \"publickey\",\n        \"publickeyid\": \"allowed-key-id\"\n      }]\n    }\n  }\n}\n```\n\n**How to fix**:\n- Use the correct signing key\n- Or add your key to policy's publickeys\n- Extract key ID: `jq -r '.signatures[0].keyid' attestation.json`\n\n**This is a critical security feature** - only authorized keys can create trusted attestations.\n\n**Policy that detects this**:\n```rego\n# This is enforced by witness verify, not Rego\n# The policy specifies which public keys are authorized\n```"}], "_metadata": {"scenario": "unauthorized_signer", "attestor": "git", "error_type": "security_violation"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I prevent Attestation signed by unauthorized key?"}, {"role": "assistant", "content": "Verification fails because the attestation was signed by a key not in the policy's functionaries list.\n\n**Attack scenario prevented**: Attacker with stolen/different key trying to create fraudulent attestations.\n\n**Policy structure**:\n```json\n{\n  \"publickeys\": {\n    \"allowed-key-id\": {\n      \"keyid\": \"sha256:abc123...\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----...\"\n    }\n  },\n  \"steps\": {\n    \"build\": {\n      \"functionaries\": [{\n        \"type\": \"publickey\",\n        \"publickeyid\": \"allowed-key-id\"\n      }]\n    }\n  }\n}\n```\n\n**How to fix**:\n- Use the correct signing key\n- Or add your key to policy's publickeys\n- Extract key ID: `jq -r '.signatures[0].keyid' attestation.json`\n\n**This is a critical security feature** - only authorized keys can create trusted attestations.\n\n**Detection policy**:\n```rego\n# This is enforced by witness verify, not Rego\n# The policy specifies which public keys are authorized\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "What Rego policy detects Attestation signed by unauthorized key?"}, {"role": "assistant", "content": "Verification fails because the attestation was signed by a key not in the policy's functionaries list.\n\n**Attack scenario prevented**: Attacker with stolen/different key trying to create fraudulent attestations.\n\n**Policy structure**:\n```json\n{\n  \"publickeys\": {\n    \"allowed-key-id\": {\n      \"keyid\": \"sha256:abc123...\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----...\"\n    }\n  },\n  \"steps\": {\n    \"build\": {\n      \"functionaries\": [{\n        \"type\": \"publickey\",\n        \"publickeyid\": \"allowed-key-id\"\n      }]\n    }\n  }\n}\n```\n\n**How to fix**:\n- Use the correct signing key\n- Or add your key to policy's publickeys\n- Extract key ID: `jq -r '.signatures[0].keyid' attestation.json`\n\n**This is a critical security feature** - only authorized keys can create trusted attestations.\n\n**Detection policy**:\n```rego\n# This is enforced by witness verify, not Rego\n# The policy specifies which public keys are authorized\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why is Attestation signed by unauthorized key a security risk?"}, {"role": "assistant", "content": "Verification fails because the attestation was signed by a key not in the policy's functionaries list.\n\n**Attack scenario prevented**: Attacker with stolen/different key trying to create fraudulent attestations.\n\n**Policy structure**:\n```json\n{\n  \"publickeys\": {\n    \"allowed-key-id\": {\n      \"keyid\": \"sha256:abc123...\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----...\"\n    }\n  },\n  \"steps\": {\n    \"build\": {\n      \"functionaries\": [{\n        \"type\": \"publickey\",\n        \"publickeyid\": \"allowed-key-id\"\n      }]\n    }\n  }\n}\n```\n\n**How to fix**:\n- Use the correct signing key\n- Or add your key to policy's publickeys\n- Extract key ID: `jq -r '.signatures[0].keyid' attestation.json`\n\n**This is a critical security feature** - only authorized keys can create trusted attestations.\n\n**Detection policy**:\n```rego\n# This is enforced by witness verify, not Rego\n# The policy specifies which public keys are authorized\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why does verification fail with 'Must run in CI environment'?"}, {"role": "assistant", "content": "Verification fails because the CI environment variable is not set.\n\n**Attack scenario prevented**: Attacker running builds on their local machine instead of trusted CI.\n\n**Policy enforcement**:\n```rego\nnot \"CI\" in input.variables  # Checks for CI env var\n```\n\n**How to fix**:\n- Run in actual CI (GitHub Actions, GitLab CI, etc.)\n- CI systems automatically set CI=true\n- For local testing, temporarily remove this policy\n\n**Why this matters**: Ensures builds only happen in controlled, auditable CI environments.\n\n**Policy that detects this**:\n```rego\npackage environment\n\nimport rego.v1\n\ndeny contains msg if {\n    not \"CI\" in input.variables\n    msg := \"Must run in CI environment\"\n}\n```"}], "_metadata": {"scenario": "missing_ci_environment", "attestor": "environment", "error_type": "security_violation"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I prevent Not running in CI environment?"}, {"role": "assistant", "content": "Verification fails because the CI environment variable is not set.\n\n**Attack scenario prevented**: Attacker running builds on their local machine instead of trusted CI.\n\n**Policy enforcement**:\n```rego\nnot \"CI\" in input.variables  # Checks for CI env var\n```\n\n**How to fix**:\n- Run in actual CI (GitHub Actions, GitLab CI, etc.)\n- CI systems automatically set CI=true\n- For local testing, temporarily remove this policy\n\n**Why this matters**: Ensures builds only happen in controlled, auditable CI environments.\n\n**Detection policy**:\n```rego\npackage environment\n\nimport rego.v1\n\ndeny contains msg if {\n    not \"CI\" in input.variables\n    msg := \"Must run in CI environment\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "What Rego policy detects Not running in CI environment?"}, {"role": "assistant", "content": "Verification fails because the CI environment variable is not set.\n\n**Attack scenario prevented**: Attacker running builds on their local machine instead of trusted CI.\n\n**Policy enforcement**:\n```rego\nnot \"CI\" in input.variables  # Checks for CI env var\n```\n\n**How to fix**:\n- Run in actual CI (GitHub Actions, GitLab CI, etc.)\n- CI systems automatically set CI=true\n- For local testing, temporarily remove this policy\n\n**Why this matters**: Ensures builds only happen in controlled, auditable CI environments.\n\n**Detection policy**:\n```rego\npackage environment\n\nimport rego.v1\n\ndeny contains msg if {\n    not \"CI\" in input.variables\n    msg := \"Must run in CI environment\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why is Not running in CI environment a security risk?"}, {"role": "assistant", "content": "Verification fails because the CI environment variable is not set.\n\n**Attack scenario prevented**: Attacker running builds on their local machine instead of trusted CI.\n\n**Policy enforcement**:\n```rego\nnot \"CI\" in input.variables  # Checks for CI env var\n```\n\n**How to fix**:\n- Run in actual CI (GitHub Actions, GitLab CI, etc.)\n- CI systems automatically set CI=true\n- For local testing, temporarily remove this policy\n\n**Why this matters**: Ensures builds only happen in controlled, auditable CI environments.\n\n**Detection policy**:\n```rego\npackage environment\n\nimport rego.v1\n\ndeny contains msg if {\n    not \"CI\" in input.variables\n    msg := \"Must run in CI environment\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why does verification fail with 'Unauthorized build command'?"}, {"role": "assistant", "content": "Verification fails because the command doesn't match the allowlist.\n\n**Attack scenario prevented**: Attacker modifying CI to run malicious commands (data exfiltration, backdoors).\n\n**Policy enforcement**:\n```rego\nnot input.cmd in approved_commands  # Strict command allowlist\n```\n\n**Examples of blocked commands**:\n- `[\"curl\", \"evil.com\"]` - Data exfiltration\n- `[\"rm\", \"-rf\", \"/\"]` - Destructive\n- `[\"wget\", \"malware.sh\"]` - Malware download\n\n**How to fix**:\n- Use an approved build command\n- Or add your command to the allowlist (if legitimate)\n\n**This is a critical security feature** - prevents command injection attacks.\n\n**Policy that detects this**:\n```rego\npackage commandrun\n\nimport rego.v1\n\napproved_commands := {\n    [\"go\", \"build\", \"-o\", \"app\"],\n    [\"make\", \"all\"]\n}\n\ndeny contains msg if {\n    not input.cmd in approved_commands\n    msg := sprintf(\"Unauthorized command: %v\", [input.cmd])\n}\n```"}], "_metadata": {"scenario": "malicious_command", "attestor": "command-run", "error_type": "security_violation"}}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I prevent Unauthorized build command detected?"}, {"role": "assistant", "content": "Verification fails because the command doesn't match the allowlist.\n\n**Attack scenario prevented**: Attacker modifying CI to run malicious commands (data exfiltration, backdoors).\n\n**Policy enforcement**:\n```rego\nnot input.cmd in approved_commands  # Strict command allowlist\n```\n\n**Examples of blocked commands**:\n- `[\"curl\", \"evil.com\"]` - Data exfiltration\n- `[\"rm\", \"-rf\", \"/\"]` - Destructive\n- `[\"wget\", \"malware.sh\"]` - Malware download\n\n**How to fix**:\n- Use an approved build command\n- Or add your command to the allowlist (if legitimate)\n\n**This is a critical security feature** - prevents command injection attacks.\n\n**Detection policy**:\n```rego\npackage commandrun\n\nimport rego.v1\n\napproved_commands := {\n    [\"go\", \"build\", \"-o\", \"app\"],\n    [\"make\", \"all\"]\n}\n\ndeny contains msg if {\n    not input.cmd in approved_commands\n    msg := sprintf(\"Unauthorized command: %v\", [input.cmd])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "What Rego policy detects Unauthorized build command detected?"}, {"role": "assistant", "content": "Verification fails because the command doesn't match the allowlist.\n\n**Attack scenario prevented**: Attacker modifying CI to run malicious commands (data exfiltration, backdoors).\n\n**Policy enforcement**:\n```rego\nnot input.cmd in approved_commands  # Strict command allowlist\n```\n\n**Examples of blocked commands**:\n- `[\"curl\", \"evil.com\"]` - Data exfiltration\n- `[\"rm\", \"-rf\", \"/\"]` - Destructive\n- `[\"wget\", \"malware.sh\"]` - Malware download\n\n**How to fix**:\n- Use an approved build command\n- Or add your command to the allowlist (if legitimate)\n\n**This is a critical security feature** - prevents command injection attacks.\n\n**Detection policy**:\n```rego\npackage commandrun\n\nimport rego.v1\n\napproved_commands := {\n    [\"go\", \"build\", \"-o\", \"app\"],\n    [\"make\", \"all\"]\n}\n\ndeny contains msg if {\n    not input.cmd in approved_commands\n    msg := sprintf(\"Unauthorized command: %v\", [input.cmd])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Why is Unauthorized build command detected a security risk?"}, {"role": "assistant", "content": "Verification fails because the command doesn't match the allowlist.\n\n**Attack scenario prevented**: Attacker modifying CI to run malicious commands (data exfiltration, backdoors).\n\n**Policy enforcement**:\n```rego\nnot input.cmd in approved_commands  # Strict command allowlist\n```\n\n**Examples of blocked commands**:\n- `[\"curl\", \"evil.com\"]` - Data exfiltration\n- `[\"rm\", \"-rf\", \"/\"]` - Destructive\n- `[\"wget\", \"malware.sh\"]` - Malware download\n\n**How to fix**:\n- Use an approved build command\n- Or add your command to the allowlist (if legitimate)\n\n**This is a critical security feature** - prevents command injection attacks.\n\n**Detection policy**:\n```rego\npackage commandrun\n\nimport rego.v1\n\napproved_commands := {\n    [\"go\", \"build\", \"-o\", \"app\"],\n    [\"make\", \"all\"]\n}\n\ndeny contains msg if {\n    not input.cmd in approved_commands\n    msg := sprintf(\"Unauthorized command: %v\", [input.cmd])\n}\n```"}]}
