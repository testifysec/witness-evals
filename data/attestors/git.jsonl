{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I attest git repository information?"}, {"role": "assistant", "content": "The git attestor automatically captures repository state:\n\n```bash\nwitness run --step build \\\n  --attestations git,commandrun,product \\\n  --outfile build-attestation.json \\\n  --key key.pem \\\n  -- go build -o myapp\n```\n\nThe git attestor captures:\n- Commit hash\n- Author and committer information\n- Branch name\n- Commit message\n- Parent commits\n- Git tags\n- Remote URLs (with credentials redacted)\n- Working directory status\n\nRego policy to enforce builds from main branch:\n\n```rego\npackage git\n\nimport rego.v1\n\ndeny contains msg if {\n    input.branch != \"main\"\n    msg := sprintf(\"Builds must be from main branch, got: %s\", [input.branch])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I ensure builds are from a clean git repository?"}, {"role": "assistant", "content": "Use a Rego policy to check the `status` field:\n\n```rego\npackage git\n\nimport rego.v1\n\n# Deny if working directory has uncommitted changes\ndeny contains msg if {\n    count(input.status) > 0\n    msg := \"Working directory must be clean (no uncommitted changes)\"\n}\n\n# List all modified files if any\ndeny contains msg if {\n    count(input.status) > 0\n    modified_files := [file | some file, status in input.status]\n    msg := sprintf(\"Uncommitted files: %v\", [modified_files])\n}\n```\n\nIn your witness policy:\n\n```json\n{\n  \"steps\": {\n    \"build\": {\n      \"attestations\": [\n        {\"type\": \"https://witness.dev/attestations/git/v0.1\"}\n      ]\n    }\n  }\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How can I enforce that commits are GPG signed?"}, {"role": "assistant", "content": "Check the `signature` field in your Rego policy:\n\n```rego\npackage git\n\nimport rego.v1\n\n# Require GPG signature on commits\ndeny contains msg if {\n    count(input.signature) == 0\n    msg := \"Commit must be GPG signed\"\n}\n\n# Validate signature format (PGP)\ndeny contains msg if {\n    not startswith(input.signature, \"-----BEGIN PGP SIGNATURE-----\")\n    msg := \"Invalid GPG signature format\"\n}\n```\n\nNote: Witness validates the signature presence, not its validity. Use git's built-in verification for cryptographic validation."}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I restrict who can author commits?"}, {"role": "assistant", "content": "Use a Rego policy to validate commit authors:\n\n```rego\npackage git\n\nimport rego.v1\n\n# Approved commit authors (email addresses)\napproved_authors := {\n    \"alice@example.com\",\n    \"bob@example.com\",\n    \"ci-bot@example.com\"\n}\n\ndeny contains msg if {\n    not input.authoremail in approved_authors\n    msg := sprintf(\"Unauthorized commit author: %s\", [input.authoremail])\n}\n\n# Ensure committer matches author (no commit forgery)\ndeny contains msg if {\n    input.authoremail != input.committeremail\n    msg := sprintf(\"Author (%s) and committer (%s) mismatch\",\n                   [input.authoremail, input.committeremail])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I validate that a release build is from a tagged commit?"}, {"role": "assistant", "content": "Check the `tags` array in git attestation:\n\n```rego\npackage git\n\nimport rego.v1\n\n# Ensure commit has at least one tag\ndeny contains msg if {\n    count(input.tags) == 0\n    msg := \"Release builds must be from tagged commits\"\n}\n\n# Validate tag name format (semantic versioning)\ndeny contains msg if {\n    some tag in input.tags\n    not regex.match(`^v[0-9]+\\.[0-9]+\\.[0-9]+$`, tag.name)\n    msg := sprintf(\"Tag must follow semver format (vX.Y.Z), got: %s\", [tag.name])\n}\n\n# Require signed tags\ndeny contains msg if {\n    some tag in input.tags\n    count(tag.pgpsignature) == 0\n    msg := sprintf(\"Tag %s must be GPG signed\", [tag.name])\n}\n```"}]}
