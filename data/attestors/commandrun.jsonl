{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I attest a Go build with the commandrun attestor?"}, {"role": "assistant", "content": "To attest a Go build with commandrun, use:\n\n```bash\nwitness run --step build \\\n  --attestations commandrun,material,product \\\n  --outfile build-attestation.json \\\n  --key key.pem \\\n  -- go build -o myapp\n```\n\nThis captures:\n- The command executed (`go build -o myapp`)\n- Exit code\n- Stdout/stderr\n- Input files (materials) and output files (products)\n\nThe corresponding Rego policy to validate the build succeeded:\n\n```rego\npackage commandrun\n\nimport rego.v1\n\ndeny contains msg if {\n    input.exitcode != 0\n    msg := sprintf(\"Build failed with exit code %d\", [input.exitcode])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How can I track all processes spawned during a build?"}, {"role": "assistant", "content": "Enable tracing with the `--trace` flag (Linux only):\n\n```bash\nwitness run --step build \\\n  --attestations commandrun \\\n  --trace \\\n  --outfile build-attestation.json \\\n  --key key.pem \\\n  -- make all\n```\n\nThis captures detailed process information:\n- All processes spawned (PIDs, parent PIDs)\n- Files opened by each process\n- Process digests (hashes of executables)\n- Command lines and environment variables\n\nRego policy to ensure only approved programs were executed:\n\n```rego\npackage commandrun\n\nimport rego.v1\n\n# Whitelist of allowed programs\napproved_programs := {\n    \"/usr/bin/gcc\",\n    \"/usr/bin/ld\",\n    \"/bin/sh\"\n}\n\ndeny contains msg if {\n    some process in input.processes\n    not process.program in approved_programs\n    msg := sprintf(\"Unauthorized program executed: %s\", [process.program])\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I run a command without printing its output to the console?"}, {"role": "assistant", "content": "Use the attestor's silent mode by configuring it in code, or capture output in the attestation only:\n\n```bash\n# The command output will still be in the attestation JSON\nwitness run --step build \\\n  --attestations commandrun \\\n  --outfile build-attestation.json \\\n  --key key.pem \\\n  -- go build -o myapp 2>&1\n```\n\nThe stdout and stderr are captured in the attestation fields:\n- `\"stdout\"`: Standard output content\n- `\"stderr\"`: Standard error content\n- `\"exitcode\"`: Process exit code\n\nRego policy to validate no errors in stderr:\n\n```rego\npackage commandrun\n\nimport rego.v1\n\ndeny contains msg if {\n    count(input.stderr) > 0\n    contains(lower(input.stderr), \"error\")\n    msg := \"Build produced errors in stderr\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I ensure a test command passed in my policy?"}, {"role": "assistant", "content": "Here's a comprehensive Rego policy for validating test execution:\n\n```rego\npackage commandrun\n\nimport rego.v1\n\n# Deny if exit code is non-zero\ndeny contains msg if {\n    input.exitcode != 0\n    msg := sprintf(\"Tests failed with exit code %d\", [input.exitcode])\n}\n\n# Deny if stderr contains failure keywords\ndeny contains msg if {\n    failure_keywords := [\"FAIL\", \"ERROR\", \"FATAL\", \"panic\"]\n    some keyword in failure_keywords\n    contains(input.stderr, keyword)\n    msg := sprintf(\"Tests produced failure output: %s\", [keyword])\n}\n\n# Ensure tests actually ran (stdout not empty)\ndeny contains msg if {\n    count(input.stdout) == 0\n    msg := \"No test output detected - tests may not have run\"\n}\n```\n\nApply this in your witness policy document under the test step."}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "Can I validate that specific commands were run in sequence?"}, {"role": "assistant", "content": "Yes, by checking the command field in your attestations. Here's a Rego policy:\n\n```rego\npackage commandrun\n\nimport rego.v1\n\n# Expected build command\nexpected_cmd := [\"go\", \"build\", \"-o\", \"myapp\"]\n\ndeny contains msg if {\n    input.cmd != expected_cmd\n    msg := sprintf(\"Unexpected build command. Expected %v, got %v\", [expected_cmd, input.cmd])\n}\n\n# Ensure certain flags are present\ndeny contains msg if {\n    not \"-trimpath\" in input.cmd\n    msg := \"Build must use -trimpath flag for reproducibility\"\n}\n\n# Ensure dangerous flags are not used\ndeny contains msg if {\n    some arg in input.cmd\n    contains(arg, \"-ldflags\")\n    contains(arg, \"-X main.secret\")\n    msg := \"Build must not embed secrets via ldflags\"\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert in the Witness supply chain attestation framework. You help users instrument CI/CD pipelines with witness, create policy documents, and write Rego policies to validate attestations. You understand all attestors in go-witness and how to use them effectively."}, {"role": "user", "content": "How do I write a policy to validate all spawned processes?"}, {"role": "assistant", "content": "When using `--trace`, you can validate all processes in the `processes` array:\n\n```rego\npackage commandrun\n\nimport rego.v1\n\n# Deny if any process exited with non-zero\ndeny contains msg if {\n    some process in input.processes\n    process.exitcode != 0\n    msg := sprintf(\"Process %s (PID %d) failed with exit code %d\",\n                   [process.program, process.processid, process.exitcode])\n}\n\n# Validate process integrity - ensure known programs\ndeny contains msg if {\n    some process in input.processes\n    count(process.programdigest) == 0\n    process.program != \"\"\n    msg := sprintf(\"Process %s has no digest - cannot verify integrity\", [process.program])\n}\n\n# Check for suspicious file access\nsuspicious_paths := [\"/etc/shadow\", \"/root/.ssh\", \"/etc/passwd\"]\n\ndeny contains msg if {\n    some process in input.processes\n    some file_path, _ in process.openedfiles\n    some suspicious in suspicious_paths\n    contains(file_path, suspicious)\n    msg := sprintf(\"Process %s accessed suspicious file: %s\", [process.program, file_path])\n}\n```"}]}
